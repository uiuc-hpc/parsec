extern "C" %{
/*
 * Copyright (c) 2019-2020 The University of Tennessee and The University
 *                         of Tennessee Research Foundation.  All rights
 *                         reserved.
 */

#include "parsec/parsec_config.h"
#include "parsec/utils/mca_param.h"

#include "parsec/data_distribution.h"
#include "parsec/data_dist/matrix/matrix.h"
#include "parsec/data_dist/matrix/two_dim_rectangle_cyclic.h"

#include <assert.h>
#include <stdarg.h>
#include <sys/time.h>
#include <mpi.h>
#if defined(PARSEC_HAVE_CUDA)
#include "parsec/mca/device/device.h"
#include <cublas_v2.h>
#endif  /* defined(PARSEC_HAVE_CUDA) */

/**
 *
 */

typedef cublasStatus_t (*cublas_dgemm_v2_t) ( cublasHandle_t handle,
                                              cublasOperation_t transa, cublasOperation_t transb,
                                              int m, int n, int k,
                                              const double *alpha,
                                              const double *A, int lda,
                                              const double *B, int ldb,
                                              const double *beta,
                                              double       *C, int ldc);

static cublasHandle_t create_or_lookup_cublas_handle(parsec_device_module_t *mod,
                                                     parsec_info_id_t cuhi,
                                                     cudaStream_t cuda_stream)
{
    cublasHandle_t ret;
    ret = parsec_info_get(&mod->infos, cuhi);
    if( NULL == ret ) {
        cublasHandle_t handle;
        cublasStatus_t status;
        /* No need to call cudaSetDevice, as this has been done by PaRSEC before calling the task body */
        status = cublasCreate(&handle);
        assert(CUBLAS_STATUS_SUCCESS == status);
        status = cublasSetStream(handle, cuda_stream);
        assert(CUBLAS_STATUS_SUCCESS == status);
        ret = parsec_info_test_and_set(&mod->infos, cuhi, handle, NULL);
        /* We are the only thread modifying this entry, so the test and set should always succeed */
        assert(ret == handle);
    }
    return ret;
}

%}

/*
 * Globals
 */
descA             [type = "two_dim_block_cyclic_t *"]
NP                [type = "int"]
CuHI              [type = "parsec_info_id_t"]
NGPUs             [type = "int"]
cuda_device_index [ type = "int *" ]

/**************************************************
 *        C Creation and destruction              *
 **************************************************/
MAKE_C(g, r)

// Execution space
g = 0 .. NGPUs-1
r = 0 .. NP-1

// Parallel partitioning
: descA(0, r)

WRITE C <- NEW
        -> C GEMM(0, g, r)

BODY
    memset(C, 0, sizeof(double)*descA->super.mt*descA->super.nt);
    parsec_advise_data_on_device(_f_C->original,
                                 cuda_device_index[g],
                                 PARSEC_DEV_DATA_ADVICE_PREFERRED_DEVICE);
END

DISCARD_C(g, r)

// Execution space
g = 0 .. NGPUs-1
r = 0 .. NP-1

// Parallel partitioning
: descA(0, r)

READ C <- C GEMM(descA->super.mt-1, g, r)

BODY

END

/**************************************************
 *                 Data Access                    *
 **************************************************/

READ_A(m, r)

// Execution space
m = 0 .. descA->super.mt-1
r = 0 .. NP-1

// Parallel partitioning
: descA(m, r)

READ A <- descA(m, r)
       -> A GEMM(m, 0, r)

BODY

END

    
/**************************************************
 *                       GEMM                     *
 **************************************************/
GEMM(m, g, r)

// Execution space
m = 0 .. descA->super.mt-1
g = 0 .. NGPUs-1
r = 0 .. NP-1

// Parallel partitioning
: descA(m, r)

// Parameters
READ A <- (g == 0) ? A READ_A(m, r) : A GEMM(m, g-1, r)
       -> ((g + 1) < NGPUs)         ? A GEMM(m, g+1, r)
RW   C <- (m == 0) ? C MAKE_C(g, r) : C GEMM(m-1, g, r)
       -> ((m + 1) < (descA->super.mt)) ? C GEMM(m+1, g, r)
                                    : C DISCARD_C(g, r)

BODY [type=CUDA
      dyld=cublasDgemm_v2 dyldtype=cublas_dgemm_v2_t
      weight=(1)]
{
    cublasStatus_t status;
    cublasHandle_t handle;
    double alpha=0.0;
    double beta=1.0;
    handle = create_or_lookup_cublas_handle(&gpu_device->super, CuHI, gpu_stream->cuda_stream);
    assert(NULL != handle);
    status = parsec_body.dyld_fn( handle,
                                  CUBLAS_OP_N, CUBLAS_OP_N, 
                                  descA->super.mb, descA->super.nb, descA->super.mb,
                                  &alpha, (double*)A, descA->super.mb,
                                  (double*)A, descA->super.mb,
                                  &beta, (double*)C, descA->super.mb );
    PARSEC_CUDA_CHECK_ERROR( "cublasDgemm_v2 ", status,
                            {return -1;} );
}
END

BODY
{
    fprintf(stderr, "Kernel GEMM(%d, %d, %d) in nvlink test is running on a CPU, which is not the intended behavior\n",
            m, g, r);
}
END


